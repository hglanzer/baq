#include "Ethernet.h"

module EthernetP
{
	provides interface Ethernet;
	uses interface GeneralIO as ssMMC;		// SS for mmc / must be set to high in this modul, otherwise driver-collision
	uses interface GeneralIO as ssETH;
	uses interface GeneralIO as rstETH;
	uses interface GeneralIO as intETH;

	uses interface SpiByte;
	uses interface Resource;
}

implementation
{
	static volatile uint8_t stateETH = UNINIT;

	uint8_t writeSPI(uint8_t opcode, uint8_t data)
	{
		uint8_t rc = 0;
		call ssETH.clr();
		rc = call SpiByte.write(opcode);	
		call ssETH.set();

		call ssETH.clr();
		rc = call SpiByte.write(data);
		call ssETH.set();

		return rc;
	}

	/*
		set registerbank: 0...3
	*/
	void setBank(uint8_t bank)
	{
		// clear bit0 and bit1 of ECON1 at first:
		call ssETH.clr();
		call SpiByte.write((ENC28J60_BIT_FIELD_CLR | ECON1));
		call SpiByte.write(ECON1_BSEL1 | ECON1_BSEL0);
		call ssETH.set();
		call ssETH.clr();
		call SpiByte.write((ENC28J60_BIT_FIELD_SET | ECON1));
		call SpiByte.write(bank);
		call ssETH.set();
	}

	command uint8_t Ethernet.init(uint8_t *mac)
	{
		uint8_t rc = 0;
		if(stateETH == UNINIT)
		{
			call ssETH.makeOutput();	// must be OUTPUT or Master-function is resetted to Slave-function
							// should be done in SPI-stack, see bigAVR6/mmc/
			call ssETH.set();		// perhaps we can use this pin for Ethernet-slaveselect...?

			call rstETH.makeOutput();
			call rstETH.set();		// Ethernetboard has low-active reset / FIXME - eigenartiges verhalten wenn set to HIGH

			if(call Resource.request() == FAIL)
			{
				return FAIL;
			}
			else
			{
				stateETH = INITIALIZING;
				return SUCCESS;
			}	
/*
		call rstETH.makeOutput();
		call rstETH.set();		// Ethernetboard has low-active reset / FIXME - eigenartiges verhalten wenn set to HIGH
		call ssMMC.makeOutput();	// must be high, regardless if MMC is used or not
		call ssMMC.set();		// otherwise driver-collission: ethernetboard cann't drive MISO
			DDRB |= (1<<0);	//SS
			DDRB |= (1<<1);	//SCK
			DDRB |= (1<<2);	//MOSI
			DDRB &= ~(1<<3);//MISO

			PORTB |= (1<<0);
			PORTB |= (1<<3);
	
			SPCR |= (1<<MSTR);
			SPCR &= ~(1<<CPOL);
			SPCR &= ~(1<<DORD);
			SPCR &= ~(1<<SPR0);
			SPCR &= ~(1<<SPR1);
			SPCR |= (1<<SPE);
while(1)
{
		PORTB &= ~(1<<0);
			writeSPI(0xff, 0xff); // soft-reset
			rc = writeSPI((ENC28J60_READ_CTRL_REG | ESTAT), (ENC28J60_READ_CTRL_REG | ESTAT));
			writeSPI((ENC28J60_WRITE_CTRL_REG | ETXSTL), 0x00);
			writeSPI((ENC28J60_WRITE_CTRL_REG | ETXSTH), 0x00);
			
			writeSPI((ENC28J60_WRITE_CTRL_REG | ETXNDL), 0xFC);
			writeSPI((ENC28J60_WRITE_CTRL_REG | ETXNDH), 0x0F);

			rc = writeSPI(0x06, 0x06);
			PORTA = rc;
		PORTB |= (1<<0);
};
*/

		}
		else
		{
			return FAIL;
		}
	}

	event void Resource.granted(void)
	{
		volatile uint8_t rc = 0, count=0;
	
		call ssETH.set();		// start with HIGH-level
		call ssMMC.makeOutput();	// must be high, regardless if MMC is used or not
		call ssMMC.set();		// otherwise driver-collission: ethernetboard cann't drive MISO
	
		switch(stateETH)
		{
			case INITIALIZING:
DDRA = 0xFF;
PORTA = 0x0F;
				// perform soft reset, write 0xFF
/*
*/
				call ssETH.clr();		// slave select - low-active
				call SpiByte.write(ENC28J60_SOFT_RESET);
				call SpiByte.write(ENC28J60_SOFT_RESET);
				call ssETH.set();		// start with HIGH-level

				for(rc = 0; rc < 255; rc++)
				{
					for(count = 0; count < 255; count++)
					{
						// just waiting...
						;
					}
				}
				
				// after that, wait for oscillcator timer to expire - about 300us
				// wait until OST has expired: LSB in ESTAT will become 1. no bank select needed for ESTAT
				do
				{
					call ssETH.clr();
					rc = call SpiByte.write((ENC28J60_READ_CTRL_REG | ESTAT));
					rc = call SpiByte.write((ENC28J60_READ_CTRL_REG | ESTAT));
					call ssETH.set();
				}while((rc & ESTAT_CLKRDY) == 0);

PORTA = 0x55;
				// OST has expired, PHY is ready... go on

				/*
					BANK0 - STUFF	
					Pointer Options
				*/

				// set RX - buffer. we have 8kb RAM as shared rx AND tx buffer
				// ~1500byte for TX(1 MTU-frame), rest for RX

				//set START-adress for RX
				call ssETH.clr();
				rc = call SpiByte.write((ENC28J60_WRITE_CTRL_REG | ERXSTL));
				rc = call SpiByte.write(RXSTART_INIT & 0xFF);
				call ssETH.set();
				call ssETH.clr();
				rc = call SpiByte.write((ENC28J60_WRITE_CTRL_REG | ERXSTH));
				rc = call SpiByte.write(RXSTART_INIT >> 8);
				call ssETH.set();
				
				//set END-adress for RX
				call ssETH.clr();
				rc = call SpiByte.write((ENC28J60_WRITE_CTRL_REG | ERXNDL));
				rc = call SpiByte.write(RXSTOP_INIT & 0xFF);
				call ssETH.set();
				call ssETH.clr();
				rc = call SpiByte.write((ENC28J60_WRITE_CTRL_REG | ERXNDH));
				rc = call SpiByte.write(RXSTOP_INIT & 0xFF);
				call ssETH.set();
				
				//set ERXRDPT with same values as ERXST, as suggested in datasheet, 6.1
				call ssETH.clr();
				rc = call SpiByte.write((ENC28J60_WRITE_CTRL_REG | ERXRDPTL));
				rc = call SpiByte.write(RXSTART_INIT & 0xFF);
				call ssETH.set();
				call ssETH.clr();
				rc = call SpiByte.write((ENC28J60_WRITE_CTRL_REG | ERXRDPTH));
				rc = call SpiByte.write(RXSTART_INIT >> 8);
				call ssETH.set();

				//set START-adress for TX
				call ssETH.clr();
				rc = call SpiByte.write((ENC28J60_WRITE_CTRL_REG | ETXSTL));
				rc = call SpiByte.write(TXSTART_INIT & 0xFF);
				call ssETH.set();
				call ssETH.clr();
				rc = call SpiByte.write((ENC28J60_WRITE_CTRL_REG | ETXSTH));
				rc = call SpiByte.write(TXSTART_INIT >> 8);
				call ssETH.set();
				
				/*	
					BANK1 - STUFF
					Filter Options
				*/
				// switch to Bank 1
				setBank(0x01);

				/*
					BANK2 - STUFF
					MAC - Options
				*/
				// switch to Bank 2
				setBank(0x02);
				call ssETH.clr();
				rc = call SpiByte.write((ENC28J60_WRITE_CTRL_REG | MACON1));
				rc = call SpiByte.write(TXSTART_INIT & 0xFF);
				call ssETH.set();


				setBank(0x03);
				
//				/*	
				//DEBUGGING only. read one of the values just set and write to PORTA-leds for checking...
				call ssETH.clr();
				rc = call SpiByte.write(ENC28J60_READ_CTRL_REG | ECON1);
				rc = call SpiByte.write(ENC28J60_READ_CTRL_REG | ECON1);
				call ssETH.set();
				PORTA = MACON1;
				while(1)
				{
				};
//				*/

				call Resource.release();
				signal Ethernet.initDone();
			break;

			case RX:

			break;
	
			case TX:

			break;
		}
	}
}
