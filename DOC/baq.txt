
### aufbau der build-environment ###

* copy -r /opt/tinyos --> homedir
* setzen der env-variablen:	TOSDIR	
				TOSROOT
				MAKERULES

### aufbau einer platform ###

* siehe dokument "TOS platform creation.pdf"
* ./tinyos-2.x/platforms/<PLATFORMNAME>
* ./tinyos-2.x/platforms/<PLATFORMNAME>/hardware.h

* ./tinyos-2.x/platforms/<PLATFORMNAME>/.platform
	(
		--> anpassen der @includes
	)

* ./tinyos-2.x/support/make/<PLATFORNAME>.target
	(	
		--> kopieren eines bestehende files
		--> umschreiben des targets auf <PLATFORMNAME>
	)


-------------------------------------

### tinyos ###

application besteht aus components, welche 'gewired' werden.
components haben	* spezifikation
			* implementation

components bieten interfaces an und benutzen events(welche von den 
interfaces der 'wired' components zur verfügung gestellt werden)

es gibt 2 arten von components:	* modules
				* configurations
					
interfaces sind bidirectional: bieten 'commands' und 'events' an


## Boot Sequence ##

The TinyOS boot sequence has four steps:

   1. Scheduler initialization
   2. Component initialization
   3. Signal that the boot process has completed
   4. Run the scheduler 


			INITIALISIERUNG

alles beginnt mit tos/system/RealMainP.nc - enthält main(). 
hier werden die init-funktionen der reihe nach aufgerufen:
		* platform_bootstrap();		// MAKRO in tos.h
		* call Scheduler.init(); 	// SchedulerBasicP.nc
		* call PlatformInit.init();	// Plattformabhängig - variabel je nach wiring:
						zb. stellt tos/platforms/mica/PlatformP.nc diese
						init() - funktion zur verfügung

			in PlatformInit.init() wird mittels
			call MeasureClock.init();
			die CPU-Clock gemessen. 

			--> VERWENDUNG EINER EXTERNEN CLOCK auf MICA-Platform für Timer0
			
			
UMSTELLUNG AUF SYNCRONE(CPU) - CLOCK --> eigenes Modul in tos/system/timerSync
	* AC0 in ASSR = 0 setzen(cpu- statt externe clock)
	* PowerDown - Problem: McuSleepC.nc in tos/chips/atm128
			--> DEFINITV BESTÄTIGT!

	* umschreiben sämtlicher filename von *Async* --> *Sync*
	* umschreiben der definitionen von *Async* --> *Sync* (da wo sie vorkommen...)
	* zusätzlicher prescaler in HplAtm128Timer0SyncP.nc(interruptroutine SIG_OUTPUT_COMPARE0)
	* in platform.h --> setzen eines PRESCALER-Wertes
		--> falls nicht gesetzt: DEFINE PRESCALER 1 (#ifndef)

---------------------------------------------------------------------------------------------------------

UART - einbau
	* UART0 / UART1: optimal wäre ein generisches interface
		--> zuviel aufwand fürs erste. statische module für je UART0 und UART1
	* TX: ISR fuer sendString - senden der einzelnen tasks per funktionsaufruf - NICHT PER TASK!
			--> zuviel overhead / ruiniert timing!

	* RX per ISR / funkt prinzipiell. welche interfaces sollen hier zur verfügung gestellt werden?


** BESSER **
	verwenden des tinyos - uartstacks. fürs erste UartByte und UartStream verwendet.
	
	PROBLEME:	*falsche baudrateberechnung in platforms/bigAVR6/MeasureClockC.nc in 			
			Atm128Calibrate.baudrateRegister(). wenn return 8 --> 57600BAUD x 2(doublespeed wird gesetzt)
			im speziellen wird der wert 'cycles' falsch berechnet. möglicherweise auswirkungen auf 
			ADC/prescaler!

			deshalb rückgabewert in baudrateRegister() FIX mit 8 eingestellt. --> 57600 BAUD
			allerdings wird in HplAtm128UartP.nc beim init() der UART-Register UARTX2 = 1 aktiviert
			--> resultierende Baudrate daher 2x57600 = 115200 8N1

			
			*Port B funktioniert(wiring mit Atm128Uart1C) 
			* PORT A(Atm128Uart0C) funktioniert *NICHT* wenn jumper J21 auf external programmer!

			implementierung der 2 uart-schnittstellen: 2 versch. interfaces bigAVR6UART0/1
			die jeweils auf Atm128Uart0 / 1 wired werden

	** ACHTUNG **
	PortD3 = UART1_TX / hier hängt auch die RTC dran. RTC per SW15 deaktivieren!

---------------------------------------------------------------------------------------------------------


LCD2x16
	* module in platform/bigAVR6/lcd2x16
	* ACHTUNG: nach kompletten power-off des boards: hw-init des lcd dauert SEHR lange(länger als bootup von
		tinyos) --> deswegen funktioniert das lcd nach wiederanstecken nicht
		--> softreset durchführen, dann passts

	FRAGE: wie sollen die wartezeiten beim senden von befehlen / daten realisiert werden?
		momentan busywait. problem könnte sein dass Timerinterface im untermodul lcd2x16 
		nicht verfügbar ist...

-------------------------------------------------------------------------------------------------------------

ETHERNET

	2 interruptquellen / davon nur eine interessant: !INT - FALLENDE FLANKE
	falls verwendet - mit pin für externen interrupt verbinden mittel GpioInterrupt


	** verbindung bigAVR6 <--> EthernetBoard

	PB0(!SS)	--------------->	!CS
	PB1(SCK)	--------------->	SCK
	PB2(MOSI)	--------------->	MOSI
	PB3(MISO)	--------------->	MISO
	PD2(EXTINT2)	--------------->	INT	falling edge

	VCC		--------------->	VCC
	GND		--------------->	GND

	eventuell noch !RST und !INT anschliessen

	startup:
	keine LESE / SCHREIBOPERATIONEN solange CLKRDY in ESTATS == 0(POLLING...)

	LEDS: 3 Leds am Board


	** SPI Instruction Set **

	Read Control Register		0 0 0 a a a a a			
	Read Buffer Memory		0 0 1 1 1 0 1 0		read from 8kb RX/TX buffer
	Write Control Register		0 1 0 a a a a a	+ data	
	Write Buffer Memory		0 1 1 1 1 0 1 0 + data	write to  8kb RX/TX buffer
	Bit Field Set			1 0 0 a a a a a + data	write to ETH/MAC/MII register
	Bit Field Clear			1 0 1 a a a a a	+ data
	System Command (Soft Reset)   	1 1 1 1 1 1 1 1


	AUTOINCREMENT RX/TX - buffer
	ERXFCON.CRCEN = 1  / CRC geprüft & defekte pakete werden verworfen(RX)
	MACON3.PADCFG<2:0> / padding + CRC automatisch berechnet?
	HALF DUPLEX verwenden

	** Control Register

	1. auswahl der bank				@ECON1 / 0x1F, alle 4 bänke




	** initialisierung

	1. RX buffer, setzen von ERXST und ERXND auf gerade adressen, TX buffer verwendet autom. rest
	2. receive buffers ERXFCON
	3. OST abwarten, ESTAT_CLKRDY = 1?
	4. MAC init - pdf seite 36
		1 MARST	= 0	(get out of reset)	@ MACON2
		2 MARXEN	= 1	(enable RX)	@ MACON1
		3 PADCFG, TXCRCEN, FULDPX 		@ MACON3
		4 diverses				@ MACON4
		5 setzen der maximalen framelänge	@ MAMXFL
		6 back-to-back inter packet gap		@ MABBIPG	0x12 for half duplex?
		7 non-back-to-back inter packet gap	@ MAIPGL	0x12
		8 					@ MAIPGH	0xc
		9
		10 set mac adress			@ MAADR0 - MAADR5
-------------------------------------------------------------------------------------------------------------

*** MEMORYCARD ***

	HplAtm128SpiP.nc 

	verwendung des tinyos - spi-stacks. lowlevel-read-support
	NO WRITE, NO FILESYSTEM-support

	ACHTUNG: um spi nutzen zu können muss der jumper J21(USB PROG) nach dem download abgezogen werden,
	da sonst spi-pin auf fixen pegel gezogen wird. sollte hinfällig sein sobald internes programming
	verfügbar	
	
	ansteuerung über SPI. Vcc des microcontrollers = 5V, Vcc memoryslot = 3,3V 
		--> 74LVCC3245A bus tranceiver dazwischengeschaltet, dieser setzt die spannungspegel 5V --> 3.3V um
		umgekehrt von MCU / 5V --> MMC / 3.3V reicht ein spannungsteiler

		
	Pinzuordnung:

	ATM128 SCK	---------------------------------------------->	MMC SCK
	ATM128 MOSI	---------------------------------------------->	MMC DIN
	ATM128 MISO	<-------------- B3 CC3245A A3  <---------------	MMC DOUT
						   DIR <--------------- MMC DOUT
	ATM128 !RD	---------------------------------------------->	MMC CS
	ATM128 !RD	-------------->	CC4345A !OE
	ATM128 ALE	---------------------------------------------->	MMC CD


						________________________		_________________
				----------------|B3		      A3|-------x-------|DOUT		|
				|		| ** BUS Transceiver **	|  	|	|		|
				|	--------|!OE		     DIR|--------	|   ** MMC **	|
				|	|	|_______________________|		|		|
	_________________	|	|						|		|
	|     PB3 / MISO|--------	|						|		|
	|     PB2 / MOSI|---------------+-----------------------------------------------|DIN		|
	|     PB1 / SCK	|---------------+-----------------------------------------------|SCK		|
	|		|		|						|		|
	| ** ATM 128 **	|		|						|		|
	|		|		|						|		|
	|     PG1 / !RD	|---------------x-----------------------------------------------|CS		|
	|     PG2 / ALE	|---------------------------------------------------------------|CD		|
	|_______________|								|_______________|


ALE = Adress Latch Enable to external memory
!RD = Read strobe to external memory


		wenn PG1 = LOW --> chipselect von MMC, ausserdem ist transceiverchip eingeschaltet. ansonsten
		trennung der 2 busse

		PG2: sobald mmc in slot eingesteckt --> kontakt wird geschlossen, und damit PG2 auf LOW gezogen

		http://elm-chan.org/docs/mmc/sdinit.png


---------------------------------------------------------------------------------------------------------------------

	ETHERNET + IP + UDP - stack

	ACHTUNG - folgende einschränkgungen:
			* KEINE FRAGMENTATION auf ip-level!	--> flags/fragment offset	= 0x0000 KONSTANT
								--> identification 		= 0x6666 KONSTANT
			* KEINE OPTIONS auf ip-level(--> ip-header ist IMMER nur 20byte gross, keine options/padding)
			* type of service = 0
			* IP - checksum wird richtig berechnet(aber eben immer nur für 20byte, keine options, s.o.)
			* UDP-level - CHECKSUM = 0x0000. dies ist erlaubt, checksum wird also ignoriert.

			*** KEIN TCP IMPLEMENTIERT ***
			***	   UDP ONLY	   ***
		

---------------------------------------------------------------------------------------------------------------------


---------------------------------------------------------------------------------------------------------------------


## FLASH der platform ##

flash mittels AVRISP mkII ueber usb-port

stecker AVRISP <--> bigAVR6:

     rotes Kabel = VCC
	|
	|
	v
	ooo
	ooo
MOSI ___|||
SCK  ____||
RESET_____|

momentan gibt es noch kein einheitliches Make-file, derzeit werden 2
verschiedene Makefiles verwendet.

1. erstellen des ihex - bin-file
2. runterladen dieses ihex-files in EPROM

cd TOSROOT
cd apps/<app-NAME>/
make bigAVR6		# angepasstes tinyos - makefile, erstellt main.ihex
cd build/bigAVR6
make install		# von ESE, download mittels avrdude


## ANPASSEN DES MAKEFILES ##
um zukünftig nur mehr 1 makefile und damit damit einem kommando kompilieren +
downloaden zu können, wurden folgende anpassungen gemacht:

	-->	erweitern des AVR_HELP - targets: zeile mit avrdude
	-->	unter umständen muss dies noch erweitert werden damit
		connection-port mitgegeben werden kann
		<TOSROOT>/support/make/avr/avr.rules

	<TOSROOT>/support/make/avr/avrdude.extra:

	-->	file wurde von dapa.extra kopiert. hier sind die eigentlichen
		flash-targets eingetragen. $(MAIN_IHEX) enthaelt den relativen
		pfad zum ihex - binaryfile

damit ergibt sich folgende commandline zum kompilieren UND flashen:

make bigAVR6 install avrdude

um diesen aufruf noch zu verkürzen wurde fuer avr-boards der
default-programmer auf 'avrdude' gesetzt:
	
		<TOSROOT>/support/make/avr/avr.rules
			DEFAULT_PROGRAM ?= avrdude

## ADC / Touchscreen

x - koordinaten auf channel 0 PORTF0
y - koordinaten auf channel 1 PORTF1

um x zu lesen: driveA = PORTG3 = 1, PORTG4 = 0
um y zu lesen: driveB = PORTG4 = 1, PORTG3 = 0

es wird das interface Atm128AdcSingle / getData verwendet
leftJustfiy = 0, prescaler tw. auf 5, ref-voltage => hier gibt es einen jumper
J18 / rechts neben GLCD... ??

