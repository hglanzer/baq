
### aufbau der build-environment ###

* copy -r /opt/tinyos --> homedir
* setzen der env-variablen:	TOSDIR	
				TOSROOT
				MAKERULES

### aufbau einer platform ###

* siehe dokument "TOS platform creation.pdf"
* ./tinyos-2.x/platforms/<PLATFORMNAME>
* ./tinyos-2.x/platforms/<PLATFORMNAME>/hardware.h

* ./tinyos-2.x/platforms/<PLATFORMNAME>/.platform
	(
		--> anpassen der @includes
	)

* ./tinyos-2.x/support/make/<PLATFORNAME>.target
	(	
		--> kopieren eines bestehende files
		--> umschreiben des targets auf <PLATFORMNAME>
	)


-------------------------------------

### tinyos ###

application besteht aus components, welche 'gewired' werden.
components haben	* spezifikation
			* implementation

components bieten interfaces an und benutzen events(welche von den 
interfaces der 'wired' components zur verfügung gestellt werden)

es gibt 2 arten von components:	* modules
				* configurations
					
interfaces sind bidirectional: bieten 'commands' und 'events' an


## Boot Sequence ##

The TinyOS boot sequence has four steps:

   1. Scheduler initialization
   2. Component initialization
   3. Signal that the boot process has completed
   4. Run the scheduler 


			INITIALISIERUNG

alles beginnt mit tos/system/RealMainP.nc - enthält main(). 
hier werden die init-funktionen der reihe nach aufgerufen:
		* platform_bootstrap();		// MAKRO in tos.h
		* call Scheduler.init(); 	// SchedulerBasicP.nc
		* call PlatformInit.init();	// Plattformabhängig - variabel je nach wiring:
						zb. stellt tos/platforms/mica/PlatformP.nc diese
						init() - funktion zur verfügung

			in PlatformInit.init() wird mittels
			call MeasureClock.init();
			die CPU-Clock gemessen. 

			--> VERWENDUNG EINER EXTERNEN CLOCK auf MICA-Platform für Timer0
			
			
UMSTELLUNG AUF SYNCRONE(CPU) - CLOCK --> eigenes Modul in tos/system/timerSync
	* AC0 in ASSR = 0 setzen(cpu- statt externe clock)
	* PowerDown - Problem: McuSleepC.nc in tos/chips/atm128
			--> DEFINITV BESTÄTIGT!

	* umschreiben sämtlicher filename von *Async* --> *Sync*
	* umschreiben der definitionen von *Async* --> *Sync* (da wo sie vorkommen...)
	* zusätzlicher prescaler in HplAtm128Timer0SyncP.nc(interruptroutine SIG_OUTPUT_COMPARE0)
	* in platform.h --> setzen eines PRESCALER-Wertes
		--> falls nicht gesetzt: DEFINE PRESCALER 1 (#ifndef)

---------------------------------------------------------------------------------------------------------

UART - einbau
	* UART0 / UART1: optimal wäre ein generisches interface
		--> zuviel aufwand fürs erste. statische module für je UART0 und UART1
	* TX: ISR fuer sendString - senden der einzelnen tasks per funktionsaufruf - NICHT PER TASK!
			--> zuviel overhead / ruiniert timing!

	* RX per ISR / funkt prinzipiell. welche interfaces sollen hier zur verfügung gestellt werden?


** BESSER **
	verwenden des tinyos - uartstacks. fürs erste UartByte und UartStream verwendet.
	
	PROBLEME:	*falsche baudrateberechnung in platforms/bigAVR6/MeasureClockC.nc in 			
			Atm128Calibrate.baudrateRegister(). wenn return 8 --> 57600BAUD x 2(doublespeed wird gesetzt)
			im speziellen wird der wert 'cycles' falsch berechnet. möglicherweise auswirkungen auf 
			ADC/prescaler!

			deshalb rückgabewert in baudrateRegister() FIX mit 8 eingestellt. --> 57600 BAUD
			allerdings wird in HplAtm128UartP.nc beim init() der UART-Register UARTX2 = 1 aktiviert
			--> resultierende Baudrate daher 2x57600 = 115200 8N1

			
			*Port B funktioniert(wiring mit Atm128Uart1C) 
			* PORT A(Atm128Uart0C) funktioniert *NICHT* wenn jumper J21 auf external programmer!

			implementierung der 2 uart-schnittstellen: 2 versch. interfaces bigAVR6UART0/1
			die jeweils auf Atm128Uart0 / 1 wired werden

	** ACHTUNG **
	PortD3 = UART1_TX / hier hängt auch die RTC dran. RTC per SW15 deaktivieren!

---------------------------------------------------------------------------------------------------------


LCD2x16
	* module in platform/bigAVR6/lcd2x16
	* ACHTUNG: nach kompletten power-off des boards: hw-init des lcd dauert SEHR lange(länger als bootup von
		tinyos) --> deswegen funktioniert das lcd nach wiederanstecken nicht
		--> softreset durchführen, dann passts

	FRAGE: wie sollen die wartezeiten beim senden von befehlen / daten realisiert werden?
		momentan busywait. problem könnte sein dass Timerinterface im untermodul lcd2x16 
		nicht verfügbar ist...



-------------------------------------------------------------------------------------------------------------

*** MEMORYCARD ***

	HplAtm128SpiP.nc 
	
	ansteuerung über SPI. Vcc des microcontrollers = 5V, Vcc memoryslot = 3,3V 
		--> 74LVCC3245A bus tranceiver dazwischengeschaltet, dieser setzt die spannungspegel 5V --> 3.3V um
		umgekehrt von MCU / 5V --> MMC / 3.3V reicht ein spannungsteiler

		
	Pinzuordnung:

	ATM128 SCK	---------------------------------------------->	MMC SCK
	ATM128 MOSI	---------------------------------------------->	MMC DIN
	ATM128 MISO	<-------------- B3 CC3245A A3  <---------------	MMC DOUT
						   DIR <--------------- MMC DOUT
	ATM128 !RD	---------------------------------------------->	MMC CS
	ATM128 !RD	-------------->	CC4345A !OE
	ATM128 ALE	---------------------------------------------->	MMC CD


						________________________		_________________
				----------------|B3		      A3|-------x-------|DOUT		|
				|		| ** BUS Transceiver **	|  	|	|		|
				|	--------|!OE		     DIR|--------	|   ** MMC **	|
				|	|	|_______________________|		|		|
	_________________	|	|						|		|
	|     PB3 / MISO|--------	|						|		|
	|     PB2 / MOSI|---------------+-----------------------------------------------|DIN		|
	|     PB1 / SCK	|---------------+-----------------------------------------------|SCK		|
	|		|		|						|		|
	| ** ATM 128 **	|		|						|		|
	|		|		|						|		|
	|     PG1 / !RD	|---------------x-----------------------------------------------|CS		|
	|     PG2 / ALE	|---------------------------------------------------------------|CD		|
	|_______________|								|_______________|


ALE = Adress Latch Enable to external memory
!RD = Read strobe to external memory


		wenn PG1 = LOW --> chipselect von MMC, ausserdem ist transceiverchip eingeschaltet. ansonsten
		trennung der 2 busse

		PG2: sobald mmc in slot eingesteckt --> kontakt wird geschlossen, und damit PG2 auf LOW gezogen

		http://elm-chan.org/docs/mmc/sdinit.png


## FLASH der platform ##

flash mittels AVRISP mkII ueber usb-port

stecker AVRISP <--> bigAVR6:

     rotes Kabel = VCC
	|
	|
	v
	ooo
	ooo
MOSI ___|||
SCK  ____||
RESET_____|

momentan gibt es noch kein einheitliches Make-file, derzeit werden 2
verschiedene Makefiles verwendet.

1. erstellen des ihex - bin-file
2. runterladen dieses ihex-files in EPROM

cd TOSROOT
cd apps/<app-NAME>/
make bigAVR6		# angepasstes tinyos - makefile, erstellt main.ihex
cd build/bigAVR6
make install		# von ESE, download mittels avrdude


## ANPASSEN DES MAKEFILES ##
um zukünftig nur mehr 1 makefile und damit damit einem kommando kompilieren +
downloaden zu können, wurden folgende anpassungen gemacht:

	-->	erweitern des AVR_HELP - targets: zeile mit avrdude
	-->	unter umständen muss dies noch erweitert werden damit
		connection-port mitgegeben werden kann
		<TOSROOT>/support/make/avr/avr.rules

	<TOSROOT>/support/make/avr/avrdude.extra:

	-->	file wurde von dapa.extra kopiert. hier sind die eigentlichen
		flash-targets eingetragen. $(MAIN_IHEX) enthaelt den relativen
		pfad zum ihex - binaryfile

damit ergibt sich folgende commandline zum kompilieren UND flashen:

make bigAVR6 install avrdude

um diesen aufruf noch zu verkürzen wurde fuer avr-boards der
default-programmer auf 'avrdude' gesetzt:
	
		<TOSROOT>/support/make/avr/avr.rules
			DEFAULT_PROGRAM ?= avrdude

## ADC / Touchscreen

x - koordinaten auf channel 0 PORTF0
y - koordinaten auf channel 1 PORTF1

um x zu lesen: driveA = PORTG3 = 1, PORTG4 = 0
um y zu lesen: driveB = PORTG4 = 1, PORTG3 = 0

es wird das interface Atm128AdcSingle / getData verwendet
leftJustfiy = 0, prescaler tw. auf 5, ref-voltage => hier gibt es einen jumper
J18 / rechts neben GLCD... ??

