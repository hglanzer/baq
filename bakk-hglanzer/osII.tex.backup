%%
%%
%% This file should be edited by user
%%

\chapter{MicroC/OS-II} \label{chapter:osII}

To emphasize the characteristics of tinyOS, another OS, called OS-II, is presented. 
The MicroC kernel was developed by Jean J. Labrosse.

\section{Basics}

uC/OS-II is a portable, ROMable, scalable preemptive real-time multitasking kernel, written in ANSI-C. Small portions of the sourcecode are written in assembler to adapt to different processor architectures. uC/OS-II is based on uC/OS, also called \textit{The Real Time Kernel}, which was published in 1992. uC/OS v1.11 is compatible to its successor.

uC/OS-II is used in all kinds of embedded systems, ranging from engine controls to audio equiment.

\subsection{Main Features}

Important characteristics of this real-time multitasking OS are:

\begin{itemize}
 \item Scaleable, with a minimum RAM footprint of 6KByte
 \item Maximum RAM footprint 24KByte
 \item Preemptive Scheduler
 \item 10 Kernel Services
 \item 80 System Calls
 \item Support for semaphores
 \item Support for event flags
 \item Support for Message Queues
 \item Support for Message Mailboxes
 \item Up to 250 Application Tasks
 \item Constant / Deterministic execution time for most services provided
 \item Support for large number of processor architectures
 \item Supported processors range from 8bit to 64 bit architectures
 \item Supports Multi-Threaded Applications 
\end{itemize}

\section{Differences tinyOS - MicroC/OS-II}

\subsection{Real-Time}

A real-time system is a system where not only the correctness of a calculation is important, but also the instant \textbf{when} this calculation was finished. The most import features of a real-time kernel are minimal and predictable interrupt latency and task switching latency.

While uC/OS-II supports a timely determinstic behaviour, no such assertion can be given for tinyOS.

\subsection{Scheduler}

MicroC/OS-II has a \textit{preemptive} scheduler - that means that every task gets only a limited time for using the CPU. The time a task gets for execution also depends on the tasks \textit{priority} - every task \textbf{MUST} have a different priority, because otherwise additional round-robing scheduling or similar would be necessary to handle tasks with equal priority. More important tasks get higher priority.

A task can be in 5 different states, as shown in figure \ref{fig:tasksstates}:

\begin{figure}[h]
 \centerline{\includegraphics[width=.8\columnwidth]{pics/uCtasks.png}}
  \caption{Statemachine for Tasks}
  \label{fig:tasksstates}
\end{figure}

\begin{itemize}
 \item Dormant: task is loaded in memory but not ready to run yet
 \item Read: task is ready to run, but higher-priority task is running at the moment 
 \item Running: task is in control of the cpu
 \item ISR: interrupt has occured, cpu is executing ISR instead of task
 \item Waiting: task waits for an event(completion of IO operation, ...)
\end{itemize}

In contrast, tinyOS knows only 3 states:

\begin{itemize}
 \item Queued: task is queued, but sooner queued task is running at the moment 
 \item Running: task is in control of the cpu
 \item ISR: interrupt has occured, cpu is executing ISR instead of task
\end{itemize}

Also, as already said, tinyOS uses a non-preemptive scheduler, see chapter \ref{chapter:tinyos} for details.

\subsection{Mutual Exclusion}

Whenever different tasks need to share data with each other, some points must be ensured to avoid data corruption and resource contention. Problems arise, for example, if task A gets scheduled and accesses a dataelement that is also needed by task B. If task A gets preemted by task B before task's A calculations are finished, task B works on incomplete data, possibly invalidating it's own calculations. To prevent such situations, MicroC/OS-II provides the following mechanisms:

\begin{itemize}
 \item Disabling/Enabling of interrupts with macros 
 \item Semaphores
\end{itemize}

Additionally, semaphores can be used to for syncronizing tasks, as described in the following section.

Because tinyOS uses a non-preemptive scheduler, no such constructs are neccessary. Because a task cannot get suspended, apart from an interrupt, by another task, every task is responsible to keep it's data in a consistent state.

\subsection{Inter Process Communication}


\subsection{Memory Footprint}

\subsection{Supported Platforms}

%%
%% = eof =====================================================================
%%
